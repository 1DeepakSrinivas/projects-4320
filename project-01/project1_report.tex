\documentclass[12pt]{article}
\usepackage[margin=0.8in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{multicol}

\lstset{
    basicstyle=\ttfamily\footnotesize,
    frame=single,
    breaklines=true,
    showstringspaces=false,
    backgroundcolor=\color{gray!10}
}

\title{
    \textbf{CSC 4320 Operating Systems} \\
    \large Project 01: CPU Scheduling \& Memory Management
}

\author{Deepak Srinivas Govindarajan}
\date{October 10, 2025}

\begin{document}

\maketitle
\thispagestyle{empty}

\section{Overview}

This project implements two fundamental CPU scheduling algorithms integrated with comprehensive memory management systems:

\textbf{CPU Scheduling Algorithms:}
\begin{itemize}
    \item \textbf{Shortest Job First (SJF):} Non-preemptive algorithm that selects the process with the shortest burst time from the ready queue
    \item \textbf{Round Robin (RR):} Preemptive algorithm using time quantum = 3, cycling through processes in a circular queue
\end{itemize}

\textbf{Repository:} \url{https://github.com/1DeepakSrinivas/projects-4320}

\section{Implementation Details}

\subsection{Process Scheduling Approach}

\textbf{Data Structures:} Both algorithms use identical process structures containing process ID, arrival time, burst time, and calculated metrics (waiting time, turnaround time). Memory management fields track allocated addresses, page tables, and memory requirements.

\textbf{SJF Implementation:} The algorithm maintains a ready queue and selects the process with minimum burst time at each scheduling decision. Ties are broken by earliest arrival time. Once a process starts execution, it runs to completion without preemption.

\textbf{Round Robin Implementation:} Uses a circular queue with time quantum = 3. Processes are preempted when their quantum expires and re-queued if not completed. New arrivals are added to the queue during execution, ensuring fair CPU allocation.

\subsection{Memory Management Integration}

\textbf{Contiguous Allocation:} Each algorithm tests different allocation strategies:
\begin{itemize}
    \item \textbf{First-Fit:} Allocates the first suitable memory block found
    \item \textbf{Best-Fit:} Allocates the smallest suitable block to minimize fragmentation
    \item \textbf{Worst-Fit:} Allocates the largest suitable block
\end{itemize}

\textbf{Paging System:} Processes are allocated pages dynamically with realistic memory access simulation. Page replacement occurs when frames are exhausted, using either FIFO or LRU algorithms.

\subsection{Modular Architecture}

The codebase follows clean separation with header files (\texttt{sjf.h}, \texttt{round\_robin.h}) containing macros and function declarations, while implementation files handle algorithm logic. An interactive shell script (\texttt{main.sh}) provides menu-driven execution and comparison functionality.

\section{Results}

\subsection{Test Dataset}
\begin{multicols}{2}
\begin{verbatim}
PID  Arrival  Burst  Priority
1    0        5      2
2    2        3      1
3    4        2      3
4    5        4      2
5    6        6      1
6    8        3      4
7    10       5      2
8    12       2      3
9    13       4      1
10   15       3      2
\end{verbatim}
\end{multicols}

\subsection{Outputs}

\textbf{SJF:}
\begin{verbatim}
Gantt Chart:
| P1 | P3 | P2 | P6 | P8 | P10 | P4 | P9 | P7 | P5 |
0    5    7    10   13   15    18   22   26   31   37

Process Statistics:
PID  Arrival  Burst  Waiting  Turnaround
1    0        5      0        5
2    2        3      5        8
3    4        2      1        3
4    5        4      13       17
5    6        6      25       31
6    8        3      2        5
7    10       5      16       21
8    12       2      1        3
9    13       4      9        13
10   15       3      0        3

Average Waiting Time:    7.20
Average Turnaround Time: 10.90
\end{verbatim}
\newpage
\textbf{Round Robin:}
\begin{verbatim}
Gantt Chart:
| P1 | P2 | P1 | P3 | P4 | P5 | P6 | P7 | P8 | P9 | P4 | P10 | P5 | P7 | P9 |
0    3    6    8    10   13   16   19   22   24   27   28    31   34   36   37

Process Statistics:
PID  Arrival  Burst  Waiting  Turnaround
1    0        5      3        8
2    2        3      1        4
3    4        2      4        6
4    5        4      19       23
5    6        6      22       28
6    8        3      8        11
7    10       5      21       26
8    12       2      10       12
9    13       4      20       24
10   15       3      13       16

Average Waiting Time:    12.10
Average Turnaround Time: 15.80
\end{verbatim}

\subsection{Performance Comparison}

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Algorithm} & \textbf{Avg Wait Time} & \textbf{Avg Turnaround Time} & \textbf{Performance} \\
\hline
SJF & 7.20 & 10.90 & 40\% better wait time \\
Round Robin & 12.10 & 15.80 & Fair CPU allocation \\
\hline
\end{tabular}
\end{center}

\textbf{Key Findings:}
\begin{itemize}
    \item SJF achieves optimal average waiting time but can cause starvation of longer processes
    \item Round Robin ensures fairness with bounded waiting time: maximum $(n-1) \times 3$ units
    \item Memory management shows different fragmentation patterns based on allocation strategy
    \item Paging eliminates external fragmentation but introduces page replacement overhead
\end{itemize}

\section{Challenges}

\subsection{Algorithm Implementation}

One of the hardest parts was building the circular queue for Round Robin scheduling. A small mistake in handling the indexes could cause processes to be lost or the schedule to break.  
Another challenge was handling processes that arrived while the system was already running. The timing had to be managed carefully so that new processes entered the queue at the right moment.  

\subsection{Memory Management}

Coordinating memory allocation with scheduling was tricky. It wasnâ€™t always clear when memory should be assigned or released.  
Implementing Least Recently Used (LRU) page replacement was also a challenge, since it required tracking when each page was last accessed and identifying which one to replace.  

\subsection{System Integration}

Designing the system in a modular way was difficult. The scheduling logic and memory management had to be separated, but still work together smoothly.  
Formatting the output consistently was another issue, especially since different parts of the system needed to present results in the same style.  

\subsection{Development Environment}

Working only in the terminal with tools like WSL and Vim was a challenge at first, especially without the conveniences of modern IDEs as I opted to work in a Linux Environment. It required adjusting to a different workflow and set of tools.


\section{Conclusion}

This project demonstrates the key tradeoffs in operating system design.  
Shortest Job First (SJF) achieves the best average waiting time, but it is difficult to use in practice because it requires knowing burst times in advance and can lead to starvation.  
Round Robin is less efficient but fairer, making it better suited for interactive systems.  

The memory management component shows how CPU scheduling and memory allocation are closely connected. Different strategies lead to different levels of fragmentation and performance, reflecting the complexity of real systems.  

The modular design makes it possible to extend the system with features like priority scheduling, multilevel queues, or aging. Overall, the simulation environment provides useful insights into operating system principles and shows how theory translates into real implementation challenges and performance tradeoffs.  


\end{document}